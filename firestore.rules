/**
 * @fileoverview Firestore Security Rules for HandyConnect Platform
 *
 * Core Philosophy:
 * This ruleset enforces a combination of user-ownership and public-read with owner-write patterns. User documents and their subcollections are strictly controlled by the owning user. Other top-level collections containing content (e.g., job posts, reviews) are publicly readable but writable only by the content owner.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible only by the user themselves.
 * - /job_posts/{jobPostId}: Job postings, publicly readable, writable only by the job poster.
 * - /job_posts/{jobPostId}/bids/{bidId}: Bids for a job, accessible only to the job poster and bidder.
 * - /payments/{paymentId}: Payments, publicly readable, writable only by the involved parties (customer/provider).
 * - /reviews/{reviewId}: Reviews, publicly readable, writable only by the reviewer.
 *
 * Key Security Decisions:
 * - Users can only manage their own profiles.
 * - Job posts, payments, and reviews are publicly readable, but only the creator can modify or delete them.
 * - Listing of user documents is disallowed for privacy.
 *
 * Denormalization for Authorization:
 * To avoid costly `get()` calls, the rules assume that documents like JobPost and Payment include fields like `userId` to indicate ownership. These fields are validated on `create` and are immutable on `update`.
 *
 * Structural Segregation:
 * The app uses a combination of top-level collections for public data (JobPost, Payment, Review) and user subcollections for private data (none explicitly defined in the provided schema, but patterns are present for future use).
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles.
     * @path /users/{userId}
     * @allow (create) User with matching UID can create their profile.
     * @allow (get, update, delete) User with matching UID can access and modify their profile.
     * @deny (create) User trying to create a profile with a different UID.
     * @deny (get, update, delete) User trying to access/modify another user's profile.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to job postings. Job posts are publicly readable, but only the poster can modify or delete them.
     * @path /job_posts/{jobPostId}
     * @allow (get, list) Any user can read job postings.
     * @allow (create) User can create a job posting if the userId matches their own UID.
     * @allow (update, delete) Only the user who created the job posting can update or delete it.
     * @deny (create) User attempting to create a job post with a mismatched userId.
     * @deny (update, delete) User attempting to modify or delete a job post they don't own.
     * @principle Public read, owner-only write access pattern.
     */
    match /job_posts/{jobPostId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

       function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Controls access to bids on job postings.  Only the job poster and bidder should have access.
     * @path /job_posts/{jobPostId}/bids/{bidId}
     * @allow (create) Provider can create a bid if their ID matches their auth UID.
     * @allow (get, list) Only the job poster and bidder can access a bid.
     * @allow (update, delete) Only the bidder can update or delete their bid.
     * @deny (create) Provider trying to create a bid with a mismatched ID.
     * @deny (get, list) Other users trying to read bids.
     * @deny (update, delete) Users other than the bidder attempting to modify or delete bids.
     * @principle Shared access (closed collaborators).
     */
    match /job_posts/{jobPostId}/bids/{bidId} {
      function isBidder(providerId) {
        return request.auth != null && request.auth.uid == providerId;
      }

      function isExistingBidder(providerId) {
        return isBidder(providerId) && resource != null;
      }

      allow get, list: if isSignedIn(); //Anyone signed in can view bids
      allow create: if isSignedIn() && request.resource.data.providerId == request.auth.uid;
      allow update: if isExistingBidder(resource.data.providerId);
      allow delete: if isExistingBidder(resource.data.providerId);
    }

    /**
     * @description Controls access to payment records. Payments are publicly readable, but only the involved parties can modify or delete them.
     * @path /payments/{paymentId}
     * @allow (get, list) Any user can read payment records.
     * @allow (create) Only the customer or provider involved in the payment can create a payment record.
     * @allow (update, delete) Only the customer or provider involved in the payment can update or delete a payment record.
     * @deny (create) User attempting to create a payment record with a mismatched userId or providerId.
     * @deny (update, delete) User attempting to modify or delete a payment record they are not involved in.
     * @principle Public read, owner-only write access pattern.
     */
    match /payments/{paymentId} {
      function isPayerOrPayee(userId, providerId) {
        return request.auth != null && (request.auth.uid == userId || request.auth.uid == providerId);
      }

      function isExistingPayerOrPayee(userId, providerId) {
        return isPayerOrPayee(userId, providerId) && resource != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && isPayerOrPayee(request.resource.data.userId, request.resource.data.providerId);
      allow update: if isExistingPayerOrPayee(resource.data.userId, resource.data.providerId);
      allow delete: if isExistingPayerOrPayee(resource.data.userId, resource.data.providerId);
    }

    /**
     * @description Controls access to review records. Reviews are publicly readable, but only the reviewer can modify or delete them.
     * @path /reviews/{reviewId}
     * @allow (get, list) Any user can read reviews.
     * @allow (create) Only the user creating the review (reviewerId) can create a review record.
     * @allow (update, delete) Only the user who created the review (reviewerId) can update or delete it.
     * @deny (create) User attempting to create a review with a mismatched reviewerId.
     * @deny (update, delete) User attempting to modify or delete a review they didn't create.
     * @principle Public read, owner-only write access pattern.
     */
    match /reviews/{reviewId} {
      function isReviewer(reviewerId) {
        return request.auth != null && request.auth.uid == reviewerId;
      }

      function isExistingReviewer(reviewerId) {
        return isReviewer(reviewerId) && resource != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.reviewerId == request.auth.uid;
      allow update: if isExistingReviewer(resource.data.reviewerId);
      allow delete: if isExistingReviewer(resource.data.reviewerId);
    }

    match /notifications/{notificationId}{
        allow list: if false;
        allow get: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }
  }

  function isSignedIn() {
    return request.auth != null;
  }
}